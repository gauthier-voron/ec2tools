package main

import (
	"flag"
	"fmt"
	"strings"
)

type saveParameters struct {
	OptionContext     *string
	OptionDescription *string
	OptionNoWait      *bool
	OptionRegion      *string
	OptionReplace     *bool
	OptionVerbose     *bool
}

var DEFAULT_SAVE_CONTEXT string = DEFAULT_CONTEXT
var DEFAULT_SAVE_DESCRIPTION string = "generated by ec2tools"
var DEFAULT_SAVE_NOWAIT bool = false
var DEFAULT_SAVE_REGION string = ""
var DEFAULT_SAVE_REPLACE bool = false
var DEFAULT_SAVE_VERBOSE bool = false

var saveParams saveParameters

var saveProcOptionRegion []string

func PrintSaveUsage() {
	fmt.Printf(`Usage: %s save [options] [<intance-spec> --] <name>

Create a snapshot of the given instance with the spceified name. If an instance
specification is provided, it must describe exactly one instance. If no
instance specification is provided, you must have only one instance running.
The snapshot receives the specified name. This name can then be used as a
value for the '--image' option of the 'launch' subcommand.

Options:

  --context <path>            path of the context file (default: '%s')

  --description <text>        optional description of the snapshot

  --no-wait                   return as soon as possible instead of waiting
                              for the snapshot to be available

  --region <region-name>      make the snapshot available for the specified
                              region (by default, the snapshot is available
                              only in the saved instance region), accept
                              multiple region names separated by commas or '*'

  --replace                   if an image with the same name already exists,
                              then replace it

  --verbose                   print what is happening during the save

`,
		PROGNAME, DEFAULT_CONTEXT)
}

func savePrint(format string, a ...interface{}) {
	if *saveParams.OptionVerbose {
		fmt.Printf("[%s] ", PROGNAME)
		fmt.Printf(format, a...)
		fmt.Printf("\n")
	}
}

func needSpread(fromRegion string) bool {
	var region string

	for _, region = range saveProcOptionRegion {
		if region != fromRegion {
			return true
		}
	}

	return false
}

func doSpread(image *Image, ilist *ImageList) {
	var retchan chan *Image
	var errchan chan error
	var dlist *ImageList
	var regions []string
	var region string
	var ret *Image
	var err error

	for _, region = range saveProcOptionRegion {
		if region != image.Region {
			regions = append(regions, region)
		}
	}

	if *saveParams.OptionReplace {
		dlist = NewImageList()

		savePrint("fetch images from regions %s", regions)
		err = dlist.Fetch(image.Name, regions...)
		if err != nil {
			Error("cannot fetch images: %s", err.Error())
		}

		savePrint("wait for %d fetched images to be available",
			len(ilist.Images))
		_, err = dlist.WaitAvailable(NewTimeoutNone())
		if err != nil {
			Error("cannot wait images: %s", err.Error())
		}

		savePrint("deregister %d images from regions %s",
			len(ilist.Images), regions)
		err = dlist.Deregister()
		if err != nil {
			Error("cannot deregister images: %s", err.Error())
		}
	}

	savePrint("wait for image %s to be available", image.Id)
	image.WaitAvailable(NewTimeoutNone())

	retchan = make(chan *Image, len(regions))
	errchan = make(chan error, len(regions))

	for _, region = range regions {
		savePrint("copy instance %s to region %s",
			image.Id, region)
		go func(region string) {
			var ret *Image
			var err error

			ret, err = image.Copy(region, image.Name,
				image.Description)

			retchan <- ret
			errchan <- err
		}(region)
	}

	err = nil

	for _, region = range regions {
		ret = <-retchan
		if ret != nil {
			savePrint("created image %s on region %s",
				ret.Id, ret.Region)
			ilist.Add(ret)
		}

		if err == nil {
			err = <-errchan
		} else {
			<-errchan
		}
	}

	if err != nil {
		Error("cannot copy image: %s", err.Error())
	}
}

func doSave(instance *Ec2Instance, name string) {
	var proceedReplace bool
	var description string
	var ilist *ImageList
	var image *Image
	var err error

	savePrint("create image from %s with name '%s' on region %s",
		instance.Name, name, instance.Fleet.Region)
	description = *saveParams.OptionDescription
	image, err = CreateImage(instance, name, description)
	if err != nil {
		switch err.(type) {
		case *ImageDuplicateError:
			proceedReplace = *saveParams.OptionReplace
		default:
			proceedReplace = false
		}

		if !proceedReplace {
			Error("cannot create image: %s", err.Error())
		}

		ilist = NewImageList()

		savePrint("image creation failed because of duplicates")
		savePrint("fetch images with name '%s' from region %s",
			name, instance.Fleet.Region)
		err = ilist.Fetch(name, instance.Fleet.Region)
		if err != nil {
			Error("cannot fetch images: %s", err.Error())
		}

		savePrint("wait for %d fetched images to be available",
			len(ilist.Images))
		_, err = ilist.WaitAvailable(NewTimeoutNone())
		if err != nil {
			Error("cannot wait images: %s", err.Error())
		}

		savePrint("deregister %d fetched images from region %s",
			len(ilist.Images), instance.Fleet.Region)
		err = ilist.Deregister()
		if err != nil {
			Error("cannot deregister images: %s", err.Error())
		}

		savePrint("create image from %s with name '%s' on region %s",
			instance.Name, name, instance.Fleet.Region)
		image, err = CreateImage(instance, name, description)
		if err != nil {
			Error("cannot create image: %s", err.Error())
		}
	}

	savePrint("created image %s on region %s",
		image.Id, image.Region)

	ilist = NewImageList()
	ilist.Add(image)

	if needSpread(instance.Fleet.Region) {
		doSpread(image, ilist)
	}

	if *saveParams.OptionNoWait {
		savePrint("wait for %d images with name %s to be pending",
			len(ilist.Images), name)
		ilist.WaitPending(NewTimeoutNone())
	} else {
		savePrint("wait for %d images with name %s to be available",
			len(ilist.Images), name)
		ilist.WaitAvailable(NewTimeoutNone())
	}
}

func processSaveOptionRegion(sourceRegion string) {
	var oreg string = *saveParams.OptionRegion

	if oreg == "*" {
		saveProcOptionRegion = ListRegions()
	} else if oreg == "" {
		saveProcOptionRegion = []string{sourceRegion}
	} else {
		saveProcOptionRegion = strings.Split(oreg, ",")
	}
}

func Save(args []string) {
	var flags *flag.FlagSet = flag.NewFlagSet("", flag.ContinueOnError)
	var instances *Ec2Selection
	var name, region string
	var specs []string
	var hasSpecs bool
	var ctx *Ec2Index
	var err error
	var ok bool

	saveParams.OptionContext = flags.String("context", DEFAULT_SAVE_CONTEXT, "")
	saveParams.OptionDescription = flags.String("description", DEFAULT_SAVE_DESCRIPTION, "")
	saveParams.OptionNoWait = flags.Bool("no-wait", DEFAULT_SAVE_NOWAIT, "")
	saveParams.OptionRegion = flags.String("region", DEFAULT_SAVE_REGION, "")
	saveParams.OptionReplace = flags.Bool("replace", DEFAULT_SAVE_REPLACE, "")
	saveParams.OptionVerbose = flags.Bool("verbose", DEFAULT_SAVE_VERBOSE, "")

	flags.Parse(args[1:])
	args = flags.Args()

	if len(args) < 1 {
		Error("missing name operand")
	} else if len(args) == 1 {
		hasSpecs = false
		name = args[0]
	} else if (len(args) > 1) && (args[len(args)-2] != "--") {
		Error("unexpected operand: %s", args[len(args)-1])
	} else {
		hasSpecs = true
		specs = args[0:(len(args) - 2)]
		name = args[len(args)-1]
	}

	if (len(name) >= 4) && (name[0:4] == "ami-") {
		Error("name must not be a valid image id")
	}

	ctx, err = LoadEc2Index(*saveParams.OptionContext)
	if err != nil {
		Error("no context: %s", *saveParams.OptionContext)
	}

	if !hasSpecs {
		instances, _ = ctx.Select([]string{"//"})
	} else {
		instances, err = ctx.Select(specs)
		if err != nil {
			Error("invalid specification: %s", err.Error())
		}
	}

	if len(instances.Instances) != 1 {
		Error("must select exactly one instance (%d selected)",
			len(instances.Instances))
	}

	processSaveOptionRegion(instances.Instances[0].Fleet.Region)

	ok = false
	for _, region = range saveProcOptionRegion {
		if region == instances.Instances[0].Fleet.Region {
			ok = true
			break
		}
	}

	if !ok {
		Error("destination regions nust contain origin region '%s'",
			instances.Instances[0].Fleet.Region)
	}

	doSave(instances.Instances[0], name)
}
